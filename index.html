<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Tattoo Try-On AR</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      font-family: 'Segoe UI', Arial, sans-serif;
      color: white;
      touch-action: none;
    }
    #video, #overlayCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; }
    #overlayCanvas { z-index: 2; pointer-events: none; }

    .panel {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 100;
      background: rgba(0,0,0,0.6);
      padding: 10px 14px;
      border-radius: 24px;
      backdrop-filter: blur(10px);
    }

    .btn {
      padding: 10px 16px;
      background: rgba(255,255,255,0.2);
      border: 2px solid white;
      border-radius: 20px;
      color: white;
      font-size: 14px;
      cursor: pointer;
      white-space: nowrap;
    }
    .btn.active {
      background: gold;
      color: #000;
      font-weight: bold;
    }

    #tattooPicker {
      position: fixed;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 100;
    }
    .tattoo-thumb {
      width: 56px; height: 56px;
      border: 2px solid white;
      border-radius: 10px;
      background: white;
      cursor: pointer;
      object-fit: contain;
    }
    .tattoo-thumb.selected { border-color: gold; box-shadow: 0 0 0 2px gold; }

    #loading {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #000; display: flex; flex-direction: column;
      align-items: center; justify-content: center; z-index: 999;
      color: white; font-size: 18px;
    }
    #loading p { margin-top: 12px; font-size: 14px; color: #aaa; }
  </style>
</head>
<body>
  <div id="loading">
    üîç Loading camera and pose detection...<br>
    <p>Please allow camera access</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="overlayCanvas"></canvas>

  <div id="tattooPicker"></div>

  <div class="panel">
    <button id="captureBtn" class="btn">üì∏ Capture</button>
    <button id="uploadBtn" class="btn">‚ûï Upload PNG</button>
  </div>

  <div id="bodyPartPanel" class="panel" style="bottom: 160px; flex-wrap: wrap; max-width: 90vw;"></div>

  <input type="file" id="fileInput" accept="image/png" style="display:none" />

  <script type="module">
    // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ñ–∞–π–ª–∏ –∑ –≤–∞—à–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä—ñ—é
    const TATTOO_NAMES = ["skull", "rose"];

    const BODY_PARTS = [
      { name: "Left Shoulder", idx: 11, type: "point" },
      { name: "Right Shoulder", idx: 12, type: "point" },
      { name: "Left Elbow", idx: 13, type: "vector", end: 15 },
      { name: "Right Elbow", idx: 14, type: "vector", end: 16 },
      { name: "Left Wrist", idx: 15, type: "vector", end: 19 },
      { name: "Right Wrist", idx: 16, type: "vector", end: 20 },
      { name: "Left Hip", idx: 23, type: "point" },
      { name: "Right Hip", idx: 24, type: "point" },
      { name: "Left Knee", idx: 25, type: "vector", end: 27 },
      { name: "Right Knee", idx: 26, type: "vector", end: 28 },
      { name: "Left Ankle", idx: 27, type: "vector", end: 31 },
      { name: "Right Ankle", idx: 28, type: "vector", end: 32 }
    ];

    let currentTattoo = null;
    let tattooX = 0.5, tattooY = 0.5;
    let tattooScale = 0.3;
    let tattooAngle = 0;
    let isDragging = false;
    let dragOffsetX = 0, dragOffsetY = 0;
    let selectedBodyPart = BODY_PARTS[4];
    let activeTouches = {};
    let manualMode = false;

    const video = document.getElementById("video");
    const overlayCanvas = document.getElementById("overlayCanvas");
    const ctx = overlayCanvas.getContext("2d");
    const loading = document.getElementById("loading");
    const tattooPicker = document.getElementById("tattooPicker");
    const uploadBtn = document.getElementById("uploadBtn");
    const captureBtn = document.getElementById("captureBtn");
    const fileInput = document.getElementById("fileInput");
    const bodyPartPanel = document.getElementById("bodyPartPanel");

    function resizeCanvas() {
      overlayCanvas.width = video.videoWidth || window.innerWidth;
      overlayCanvas.height = video.videoHeight || window.innerHeight;
      redrawTattoo();
    }

    function buildTattooPicker() {
      tattooPicker.innerHTML = "";
      TATTOO_NAMES.forEach(name => {
        const img = document.createElement("img");
        img.className = "tattoo-thumb";
        img.src = `tattoos/${name}.png`;
        img.onclick = () => {
          loadTattooImage(`tattoos/${name}.png`);
          document.querySelectorAll('.tattoo-thumb').forEach(t => t.classList.remove('selected'));
          img.classList.add('selected');
        };
        tattooPicker.appendChild(img);
      });
      if (TATTOO_NAMES.length > 0) {
        tattooPicker.children[0]?.classList.add('selected');
        loadTattooImage(`tattoos/${TATTOO_NAMES[0]}.png`);
      }
    }

    function loadTattooImage(src) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        currentTattoo = img;
        manualMode = false;
        redrawTattoo();
      };
      img.onerror = () => {
        console.error("Failed to load tattoo:", src);
        createFallbackTattoo();
      };
      img.src = src;
    }

    function createFallbackTattoo() {
      const canvas = document.createElement('canvas');
      canvas.width = 200;
      canvas.height = 200;
      const ctx = canvas.getContext('2d');
      
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(100, 100, 80, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(100, 100, 60, 0, Math.PI * 2);
      ctx.fill();
      
      const img = new Image();
      img.onload = () => {
        currentTattoo = img;
        manualMode = false;
        redrawTattoo();
      };
      img.src = canvas.toDataURL();
    }

    function buildBodyPartSelector() {
      bodyPartPanel.innerHTML = "";
      BODY_PARTS.forEach(part => {
        const btn = document.createElement("button");
        btn.className = "btn";
        btn.textContent = part.name;
        btn.onclick = () => {
          selectedBodyPart = part;
          manualMode = false;
          document.querySelectorAll('#bodyPartPanel .btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
        };
        if (part === selectedBodyPart) btn.classList.add('active');
        bodyPartPanel.appendChild(btn);
      });
    }

    function redrawTattoo() {
      if (!currentTattoo) return;
      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      const w = overlayCanvas.width * tattooScale;
      const h = (currentTattoo.height / currentTattoo.width) * w;
      ctx.save();
      ctx.translate(overlayCanvas.width * tattooX, overlayCanvas.height * tattooY);
      ctx.rotate(tattooAngle);
      ctx.drawImage(currentTattoo, -w / 2, -h / 2, w, h);
      ctx.restore();
    }

    function attachTattooToBody(landmarks) {
      if (!landmarks || !currentTattoo || manualMode) return;
      const part = selectedBodyPart;

      if (part.type === "point") {
        const pt = landmarks[part.idx];
        if (pt && pt.visibility > 0.6) {
          tattooX = 0.7 * tattooX + 0.3 * pt.x;
          tattooY = 0.7 * tattooY + 0.3 * pt.y;
          redrawTattoo();
        }
      } else if (part.type === "vector") {
        const start = landmarks[part.idx];
        const end = landmarks[part.end];
        if (!start || !end || start.visibility < 0.5 || end.visibility < 0.5) return;
        const mx = (start.x + end.x) / 2;
        const my = (start.y + end.y) / 2;
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const angle = Math.atan2(dy, dx);
        const dist = Math.hypot(dx, dy);
        const newScale = Math.max(0.1, Math.min(0.8, dist * 2.5));
        tattooX = 0.7 * tattooX + 0.3 * mx;
        tattooY = 0.7 * tattooY + 0.3 * my;
        tattooScale = 0.7 * tattooScale + 0.3 * newScale;
        tattooAngle = 0.7 * tattooAngle + 0.3 * angle;
        redrawTattoo();
      }
    }

    uploadBtn.onclick = () => fileInput.click();
    fileInput.onchange = (e) => {
      const file = e.target.files[0];
      if (file && file.type === "image/png") {
        const url = URL.createObjectURL(file);
        loadTattooImage(url);
        document.querySelectorAll('.tattoo-thumb').forEach(t => t.classList.remove('selected'));
        manualMode = true;
      }
    };

    captureBtn.onclick = () => {
      const captureCanvas = document.createElement("canvas");
      captureCanvas.width = overlayCanvas.width;
      captureCanvas.height = overlayCanvas.height;
      const cctx = captureCanvas.getContext("2d");
      cctx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
      if (currentTattoo) {
        const w = captureCanvas.width * tattooScale;
        const h = (currentTattoo.height / currentTattoo.width) * w;
        cctx.save();
        cctx.translate(captureCanvas.width * tattooX, captureCanvas.height * tattooY);
        cctx.rotate(tattooAngle);
        cctx.drawImage(currentTattoo, -w / 2, -h / 2, w, h);
        cctx.restore();
      }
      const link = document.createElement("a");
      link.download = "tattoo-preview.png";
      link.href = captureCanvas.toDataURL("image/png");
      link.click();
    };

    overlayCanvas.addEventListener("touchstart", (e) => {
      if (!currentTattoo) return;
      e.preventDefault();
      const touches = e.touches;
      for (let i = 0; i < touches.length; i++) {
        activeTouches[touches[i].identifier] = { x: touches[i].clientX, y: touches[i].clientY };
      }
      if (touches.length === 1) {
        const rect = overlayCanvas.getBoundingClientRect();
        const xOnCanvas = (touches[0].clientX - rect.left) / rect.width;
        const yOnCanvas = (touches[0].clientY - rect.top) / rect.height;
        const dx = xOnCanvas - tattooX;
        const dy = yOnCanvas - tattooY;
        if (Math.hypot(dx, dy) < tattooScale) {
          isDragging = true;
          dragOffsetX = touches[0].clientX - overlayCanvas.width * tattooX;
          dragOffsetY = touches[0].clientY - overlayCanvas.height * tattooY;
          manualMode = true;
        }
      }
    });

    overlayCanvas.addEventListener("touchmove", (e) => {
      if (!currentTattoo) return;
      e.preventDefault();
      const touches = e.touches;
      for (let i = 0; i < touches.length; i++) {
        activeTouches[touches[i].identifier] = { x: touches[i].clientX, y: touches[i].clientY };
      }
      if (touches.length === 1 && isDragging) {
        tattooX = (touches[0].clientX - dragOffsetX) / overlayCanvas.width;
        tattooY = (touches[0].clientY - dragOffsetY) / overlayCanvas.height;
        redrawTattoo();
      } else if (touches.length === 2) {
        const ids = Object.keys(activeTouches);
        if (ids.length >= 2) {
          const t1 = activeTouches[ids[0]];
          const t2 = activeTouches[ids[1]];
          const dx = t1.x - t2.x;
          const dy = t1.y - t2.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const newScale = Math.max(0.1, Math.min(1.0, distance / (overlayCanvas.width * 0.8)));
          tattooScale = newScale;
          manualMode = true;
          redrawTattoo();
        }
      }
    });

    overlayCanvas.addEventListener("touchend", (e) => {
      if (!currentTattoo) return;
      for (let i = 0; i < e.changedTouches.length; i++) {
        delete activeTouches[e.changedTouches[i].identifier];
      }
      if (e.touches.length === 0) {
        isDragging = false;
      }
    });

    // –ù–ê–ô–ù–û–í–Ü–®–ê –í–ï–†–°–Ü–Ø MEDIAPIPE
    import { PoseLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/+esm";

    let poseLandmarker = null;

    async function initPose() {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
        );
        
        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            // –ê–∫—Ç—É–∞–ª—å–Ω–∏–π —à–ª—è—Ö –¥–æ –º–æ–¥–µ–ª—ñ
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker/float16/latest/pose_landmarker.task"
          },
          runningMode: "VIDEO",
          numPoses: 1
        });
        console.log("Pose Landmarker loaded successfully");
      } catch (error) {
        console.error("Error loading pose landmarker:", error);
        loading.innerHTML = "‚ùå Pose detection failed to load<br><small>Check console for details</small>";
        throw error;
      }
    }

    async function setupCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: "environment",
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        });
        video.srcObject = stream;
        
        await new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            video.play().then(resolve).catch(reject);
          };
          video.onerror = reject;
        });
        
        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);
        loading.style.display = "none";
      } catch (error) {
        console.error("Camera error:", error);
        loading.innerHTML = "‚ùå Camera access denied<br><small>Please allow camera permissions and refresh</small>";
        throw error;
      }
    }

    let lastVideoTime = -1;
    function detectPose() {
      if (video.readyState >= 2 && video.currentTime !== lastVideoTime && poseLandmarker) {
        lastVideoTime = video.currentTime;
        try {
          const results = poseLandmarker.detectForVideo(video, performance.now());
          if (results.landmarks && results.landmarks.length > 0) {
            attachTattooToBody(results.landmarks[0]);
          }
        } catch (error) {
          console.error("Pose detection error:", error);
        }
      }
      requestAnimationFrame(detectPose);
    }

    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–æ–¥–∞—Ç–∫—É
    buildTattooPicker();
    buildBodyPartSelector();
    
    async function initializeApp() {
      try {
        await initPose();
        await setupCamera();
        detectPose();
      } catch (error) {
        console.error("App initialization failed:", error);
        loading.innerHTML = "‚ùå Initialization failed<br><small>" + error.message + "</small>";
      }
    }
    
    // –ó–∞–ø—É—Å–∫–∞—î–º–æ –¥–æ–¥–∞—Ç–æ–∫
    initializeApp();
  </script>
</body>
</html>
